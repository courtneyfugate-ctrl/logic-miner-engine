# Logic Miner V.5 - Task List

## **MAIN INVIOLABLE CONSTRAINT: UNIVERSAL BLACKBOX ENGINE**
1.  **Siloed Pre-processing**: All data transformation (Text parsing, Tokenization) must be strictly **siloed** from the logic engine.
2.  **Universal Input**: The Engine accepts only **Abstract Mathematical Objects** (Matrices, Vectors, Integer Sets). It has NO knowledge of "Words", "Verbs", or "English".
3.  **Discovery Check**: Structure (Direction, Hierarchy) must match the **Algebraic Convergence** (Mahler Decay), never imposed by the Pre-processor.
4.  **Immutable Core**: The Solver logic (`fit`) must be generic.

- [x] Refactor `algebraic_text.py` (Purge NCD, Add Mapper) <!-- id: 6 -->
- [x] Create `test_pure_padic.py` (Verify Derived Distance) <!-- id: 7 -->
- [x] Run `stress_test_biology.py` (Validate at Scale) <!-- id: 8 -->

## Phase 2/V: Advanced Refinement & Optimization
- [x] **Analysis**: Intrinsic Prime Discovery (Auto-p) <!-- id: 10 -->
- [x] **Audit**: Mahler Series Integration (Decay Audit) <!-- id: 11 -->
- [x] **Audit**: 1-Lipschitz Constraint Verification <!-- id: 12 -->
- [x] **Feature**: Adelic Multi-Text Synthesis (CRT) <!-- id: 13 -->
- [x] **Optimization**: SVO Pre-Processing (Phase V) <!-- id: 14 -->

## Phase 3: Recursive Discovery & Hierarchy
- [/] **Discovery**: Recursive Re-Mapping Loop (Phase VIII) <!-- id: 15 -->
- [ ] **Audit**: Restore Mahler & Lipschitz Reporting <!-- id: 16 -->
- [ ] **Technical**: True Hensel Lifting Implementation <!-- id: 17 -->

## **CRITICAL DIRECTIVE: ALGEBRAIC DISCOVERY (NON-IMPOSITION)**
**VIOLATION DETECTED**: The current SVO Parser uses grammar to *assign* direction ($Subject \to Object$). This is forbidden.
**RULE**: The Parser must extract **undirected** semantic associations. The **Direction** of the hierarchy must be **DISCOVERED** by the Solver.
-   The Solver must test permutations of $(x, y)$ to find the configuration that minimizes $p$-adic Energy (Mahler Decay).
-   If "Whale is Mammal" creates a stable polynomial, and "Mammal is Whale" creates noise, the Solver chooses the former.
-   **NEVER** hardcode weights based on "is" vs "has". Relationships are symmetric potentials until the Field collapses them.


- [x] Run `debug_cubic.py` (Prove Solver) <!-- id: 0 -->
